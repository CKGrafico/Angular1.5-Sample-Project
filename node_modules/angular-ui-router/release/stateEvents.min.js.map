{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6**","webpack:///stateEvents.min.js","webpack:///webpack/bootstrap a4ffa6d2207b695a9deb?dbaf**","webpack:///./ng1/stateEvents.ts?2577"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","applyPairs","memo","keyValTuple","key","value","Array","isArray","isString","Error","stateChangeStartHandler","$transition$","$stateEvents","$rootScope","$state","$urlRouter","options","notify","valid","ignored","enabledEvents","provider","enabled","toParams","params","fromParams","$stateChangeSuccess","startEvent","$broadcast","to","from","defaultPrevented","$stateChangeCancel","transition","update","promise","then","$stateChangeError","error","type","evt","stateNotFoundHandler","$to$","$from$","redirectFn","target","redirect","identifier","e","state","retry","get","isFunction","$StateEventsProvider","$stateProvider","assertNotRuntime","runtime","$get","$transitions","enabledStateEvents","onInvalid","$stateChangeStart","onBefore","priority","prototype","instance","allEvents","map","reduce","enable","events","_i","arguments","length","forEach","event","disable","$inject","angular","run"],"mappings":";;;;;;CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,uBAAAH,GACA,gBAAAC,SACAA,QAAA,qBAAAD,IAEAD,EAAA,qBAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,GAEtB,cEsFD,WAGE,QAAAe,GAAoBC,EAAMC,GACxB,GAAIC,GAAKC,CAET,IADIC,MAAMC,QAAQJ,KAAeC,EAAAD,EAAA,GAAKE,EAAAF,EAAA,KACjCK,EAASJ,GAAM,KAAM,IAAIK,OAAM,mCAEpC,OADAP,GAAKE,GAAOC,EACLH,EAIT,QAAAQ,GAAiCC,EAA0BC,EAAcC,EAAYC,EAAQC,GAC3F,GAAKJ,EAAaK,UAAUC,QAAWN,EAAaO,UAAWP,EAAaQ,UAA5E,CAGA,GAAIC,GAAgBR,EAAaS,SAASC,UAGtCC,EAAWZ,EAAaa,OAAO,MAC/BC,EAAad,EAAaa,OAAO,OAErC,IAAIJ,EAAcM,oBAAqB,CACrC,GAAIC,GAAad,EAAWe,WAAW,oBAAqBjB,EAAakB,KAAMN,EAAUZ,EAAamB,OAAQL,EAAYd,EAAaK,UAAWL,EAElJ,IAAIgB,EAAWI,iBAMb,MALIX,GAAcY,oBAChBnB,EAAWe,WAAW,qBAAsBjB,EAAakB,KAAMN,EAAUZ,EAAamB,OAAQL,EAAYd,EAAaK,UAAWL,GAG3G,MAArBG,EAAOmB,YAAoBlB,EAAWmB,UACnC,CAGTvB,GAAawB,QAAQC,KAAK,WACxBvB,EAAWe,WAAW,sBAAuBjB,EAAakB,KAAMN,EAAUZ,EAAamB,OAAQL,EAAYd,EAAaK,UAAWL,KAInIS,EAAciB,mBAChB1B,EAAawB,QAAQ,SAAS,SAAUG,GACtC,IAAIA,GAAyB,IAAfA,EAAMC,MAAyD,IAAfD,EAAMC,KAApE,CAIA,GAAIC,GAAM3B,EAAWe,WAAW,oBAAqBjB,EAAakB,KAAMN,EAAUZ,EAAamB,OAAQL,EAAYa,EAAO3B,EAAaK,UAAWL,EAE7I6B,GAAIT,kBACPhB,EAAWmB,aAOnB,QAAAO,GAA8BC,EAAmBC,EAAqB7B,EAAsBD,EAAYE,GAOtG,QAAA6B,KACE,MAAO9B,GAAO+B,OAAOC,EAASjB,GAAIiB,EAASvB,SAAUuB,EAAS9B,SAPhE,GAAI8B,IAAYjB,GAAIa,EAAKK,aAAcxB,SAAUmB,EAAKlB,SAAUR,QAAS0B,EAAK1B,WAC1EgC,EAAInC,EAAWe,WAAW,iBAAkBkB,EAAUH,EAAOM,QAASN,EAAOnB,SASjF,QAPIwB,EAAEjB,kBAAoBiB,EAAEE,QAC1BnC,EAAWmB,SAMTc,EAAEjB,kBACG,EACEiB,EAAEE,OAAWpC,EAAOqC,IAAIL,EAASjB,IACnCmB,EAAEE,OAASE,EAAWJ,EAAEE,MAAMd,MAAQY,EAAEE,MAAMd,KAAKQ,GAAcA,IADnE,OAMT,QAAAS,GAA8BC,GAc5B,QAAAC,KACE,GAAIC,EAAS,KAAM,IAAI/C,OAAM,6DA2B/B,QAAAgD,GAAcC,GAQZ,MAPAF,IAAU,EAENG,EAAmC,gBACrCL,EAAeM,UAAUnB,GACvBkB,EAAmBE,mBACrBH,EAAaI,YAAapD,GAA0BqD,SAAU,OAG9D1C,SAAUgC,EAAqBW,UAAUC,UAlD7CZ,EAAqBW,UAAUC,SAAW3E,IAS1C,IAAIkE,IAAU,EACVU,GAAa,oBAAqB,iBAAkB,sBAAuB,qBAC3EP,EAAqCO,EAAUC,IAAI,SAAAnB,GAAK,OAACA,GAAG,KAAOoB,OAAOnE,KAU9EX,MAAK+E,OAAS,WFSL,IETe,GAAAC,MAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,EAAA,GAAAC,UAAAD,EACtBhB,KACKe,GAAWA,EAAOG,SAAQH,EAASJ,GACxCI,EAAOI,QAAQ,SAAAC,GAAS,MAAAhB,GAAmBgB,IAAS,KAOtDrF,KAAKsF,QAAU,WFaN,IEbgB,GAAAN,MAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,EAAA,GAAAC,UAAAD,EACvBhB,KACKe,GAAWA,EAAOG,SAAQH,EAASJ,GACxCI,EAAOI,QAAQ,SAAAC,GAAS,aAAOhB,GAAmBgB,MAGpDrF,KAAKgC,QAAU,WAAM,MAAAqC,IAErBrE,KAAKmE,KAAOA,EACZA,EAAKoB,SAAW,gBAlHb,GAAAzB,GAAA0B,QAAA1B,WAAY5C,EAAAsE,QAAAtE,QAUjBE,GAAwBmE,SAAW,eAAgB,eAAgB,aAAc,SAAU,cA2C3FpC,EAAqBoC,SAAW,OAAQ,SAAU,SAAU,aAAc,cAmB1ExB,EAAqBwB,SAAW,kBA0DhCC,QAAQ3F,OAAO,0BAA2B,oBACrCkC,SAAS,eAA0CgC,GACnD0B,KAAK,eAAgB,SAAUnE","file":"stateEvents.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"angular-ui-router\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angular-ui-router\"] = factory();\n\telse\n\t\troot[\"angular-ui-router\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"angular-ui-router\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angular-ui-router\"] = factory();\n\telse\n\t\troot[\"angular-ui-router\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * An event broadcast on `$rootScope` when the state transition **begins**.\n\t *\n\t * You can use `event.preventDefault()`\n\t * to prevent the transition from happening and then the transition promise will be\n\t * rejected with a `'transition prevented'` value.\n\t *\n\t * Additional arguments to the event handler are provided:\n\t * - `toState`: the Transition Target state\n\t * - `toParams`: the Transition Target Params\n\t * - `fromState`: the state the transition is coming from\n\t * - `fromParams`: the parameters from the state the transition is coming from\n\t * - `options`: any Transition Options\n\t * - `$transition$`: the [[Transition]]\n\t *\n\t * @example\n\t * ```\n\t *\n\t * $rootScope.$on('$stateChangeStart', function(event, transition) {\n\t *   event.preventDefault();\n\t *   // transitionTo() promise will be rejected with\n\t *   // a 'transition prevented' error\n\t * })\n\t * ```\n\t *\n\t * @deprecated use [[TransitionService.onStart]]\n\t * @event $stateChangeStart\n\t */\n\tvar $stateChangeStart;\n\t/**\n\t * An event broadcast on `$rootScope` if a transition is **cancelled**.\n\t *\n\t * Additional arguments to the event handler are provided:\n\t * - `toState`: the Transition Target state\n\t * - `toParams`: the Transition Target Params\n\t * - `fromState`: the state the transition is coming from\n\t * - `fromParams`: the parameters from the state the transition is coming from\n\t * - `options`: any Transition Options\n\t * - `$transition$`: the [[Transition]] that was cancelled\n\t *\n\t * @deprecated\n\t * @event $stateChangeCancel\n\t */\n\tvar $stateChangeCancel;\n\t/**\n\t *\n\t * An event broadcast on `$rootScope` once the state transition is **complete**.\n\t *\n\t * Additional arguments to the event handler are provided:\n\t * - `toState`: the Transition Target state\n\t * - `toParams`: the Transition Target Params\n\t * - `fromState`: the state the transition is coming from\n\t * - `fromParams`: the parameters from the state the transition is coming from\n\t * - `options`: any Transition Options\n\t * - `$transition$`: the [[Transition]] that just succeeded\n\t *\n\t * @deprecated use [[TransitionService.onStart]] and [[Transition.promise]], or [[Transition.onSuccess]]\n\t * @event $stateChangeSuccess\n\t */\n\tvar $stateChangeSuccess;\n\t/**\n\t * An event broadcast on `$rootScope` when an **error occurs** during transition.\n\t *\n\t * It's important to note that if you\n\t * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t * catch **ALL** errors.\n\t *\n\t * Additional arguments to the event handler are provided:\n\t * - `toState`: the Transition Target state\n\t * - `toParams`: the Transition Target Params\n\t * - `fromState`: the state the transition is coming from\n\t * - `fromParams`: the parameters from the state the transition is coming from\n\t * - `error`: The reason the transition errored.\n\t * - `options`: any Transition Options\n\t * - `$transition$`: the [[Transition]] that errored\n\t *\n\t * @deprecated use [[TransitionService.onStart]] and [[Transition.promise]], or [[Transition.onError]]\n\t * @event $stateChangeError\n\t */\n\tvar $stateChangeError;\n\t/**\n\t * An event broadcast on `$rootScope` when a requested state **cannot be found** using the provided state name.\n\t *\n\t * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t * lazy-loading the unfound state). A `TargetState` object is passed to the listener handler,\n\t * you can see its properties in the example. You can use `event.preventDefault()` to abort the\n\t * transition and the promise returned from `transitionTo()` will be rejected with a\n\t * `'transition aborted'` error.\n\t *\n\t * Additional arguments to the event handler are provided:\n\t * - `unfoundState` Unfound State information. Contains: `to, toParams, options` properties.\n\t * - `fromState`: the state the transition is coming from\n\t * - `fromParams`: the parameters from the state the transition is coming from\n\t * - `options`: any Transition Options\n\t * @example\n\t *\n\t * <pre>\n\t * // somewhere, assume lazy.state has not been defined\n\t * $state.go(\"lazy.state\", { a: 1, b: 2 }, { inherit: false });\n\t *\n\t * // somewhere else\n\t * $scope.$on('$stateNotFound', function(event, transition) {\n\t * function(event, unfoundState, fromState, fromParams){\n\t *     console.log(unfoundState.to); // \"lazy.state\"\n\t *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t *     console.log(unfoundState.options); // {inherit:false} + default options\n\t * });\n\t * </pre>\n\t *\n\t * @deprecated use [[StateProvider.onInvalid]] // TODO: Move to [[StateService.onInvalid]]\n\t * @event $stateNotFound\n\t */\n\tvar $stateNotFound;\n\t(function () {\n\t    var isFunction = angular.isFunction, isString = angular.isString;\n\t    function applyPairs(memo, keyValTuple) {\n\t        var key, value;\n\t        if (Array.isArray(keyValTuple))\n\t            key = keyValTuple[0], value = keyValTuple[1];\n\t        if (!isString(key))\n\t            throw new Error(\"invalid parameters to applyPairs\");\n\t        memo[key] = value;\n\t        return memo;\n\t    }\n\t    stateChangeStartHandler.$inject = ['$transition$', '$stateEvents', '$rootScope', '$state', '$urlRouter'];\n\t    function stateChangeStartHandler($transition$, $stateEvents, $rootScope, $state, $urlRouter) {\n\t        if (!$transition$.options().notify || !$transition$.valid() || $transition$.ignored())\n\t            return;\n\t        var enabledEvents = $stateEvents.provider.enabled();\n\t        var toParams = $transition$.params(\"to\");\n\t        var fromParams = $transition$.params(\"from\");\n\t        if (enabledEvents.$stateChangeSuccess) {\n\t            var startEvent = $rootScope.$broadcast('$stateChangeStart', $transition$.to(), toParams, $transition$.from(), fromParams, $transition$.options(), $transition$);\n\t            if (startEvent.defaultPrevented) {\n\t                if (enabledEvents.$stateChangeCancel) {\n\t                    $rootScope.$broadcast('$stateChangeCancel', $transition$.to(), toParams, $transition$.from(), fromParams, $transition$.options(), $transition$);\n\t                }\n\t                //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n\t                if ($state.transition == null)\n\t                    $urlRouter.update();\n\t                return false;\n\t            }\n\t            $transition$.promise.then(function () {\n\t                $rootScope.$broadcast('$stateChangeSuccess', $transition$.to(), toParams, $transition$.from(), fromParams, $transition$.options(), $transition$);\n\t            });\n\t        }\n\t        if (enabledEvents.$stateChangeError) {\n\t            $transition$.promise[\"catch\"](function (error) {\n\t                if (error && (error.type === 2 /* RejectType.SUPERSEDED */ || error.type === 3 /* RejectType.ABORTED */))\n\t                    return;\n\t                var evt = $rootScope.$broadcast('$stateChangeError', $transition$.to(), toParams, $transition$.from(), fromParams, error, $transition$.options(), $transition$);\n\t                if (!evt.defaultPrevented) {\n\t                    $urlRouter.update();\n\t                }\n\t            });\n\t        }\n\t    }\n\t    stateNotFoundHandler.$inject = ['$to$', '$from$', '$state', '$rootScope', '$urlRouter'];\n\t    function stateNotFoundHandler($to$, $from$, $state, $rootScope, $urlRouter) {\n\t        var redirect = { to: $to$.identifier(), toParams: $to$.params(), options: $to$.options() };\n\t        var e = $rootScope.$broadcast('$stateNotFound', redirect, $from$.state(), $from$.params());\n\t        if (e.defaultPrevented || e.retry)\n\t            $urlRouter.update();\n\t        function redirectFn() {\n\t            return $state.target(redirect.to, redirect.toParams, redirect.options);\n\t        }\n\t        if (e.defaultPrevented) {\n\t            return false;\n\t        }\n\t        else if (e.retry || !!$state.get(redirect.to)) {\n\t            return e.retry && isFunction(e.retry.then) ? e.retry.then(redirectFn) : redirectFn();\n\t        }\n\t    }\n\t    $StateEventsProvider.$inject = ['$stateProvider'];\n\t    function $StateEventsProvider($stateProvider) {\n\t        $StateEventsProvider.prototype.instance = this;\n\t        var runtime = false;\n\t        var allEvents = ['$stateChangeStart', '$stateNotFound', '$stateChangeSuccess', '$stateChangeError'];\n\t        var enabledStateEvents = allEvents.map(function (e) { return [e, true]; }).reduce(applyPairs, {});\n\t        function assertNotRuntime() {\n\t            if (runtime)\n\t                throw new Error(\"Cannot enable events at runtime (use $stateEventsProvider\");\n\t        }\n\t        /**\n\t         * Enables the deprecated UI-Router 0.2.x State Events\n\t         * [ '$stateChangeStart', '$stateNotFound', '$stateChangeSuccess', '$stateChangeError' ]\n\t         */\n\t        this.enable = function () {\n\t            var events = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                events[_i - 0] = arguments[_i];\n\t            }\n\t            assertNotRuntime();\n\t            if (!events || !events.length)\n\t                events = allEvents;\n\t            events.forEach(function (event) { return enabledStateEvents[event] = true; });\n\t        };\n\t        /**\n\t         * Disables the deprecated UI-Router 0.2.x State Events\n\t         * [ '$stateChangeStart', '$stateNotFound', '$stateChangeSuccess', '$stateChangeError' ]\n\t         */\n\t        this.disable = function () {\n\t            var events = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                events[_i - 0] = arguments[_i];\n\t            }\n\t            assertNotRuntime();\n\t            if (!events || !events.length)\n\t                events = allEvents;\n\t            events.forEach(function (event) { return delete enabledStateEvents[event]; });\n\t        };\n\t        this.enabled = function () { return enabledStateEvents; };\n\t        this.$get = $get;\n\t        $get.$inject = ['$transitions'];\n\t        function $get($transitions) {\n\t            runtime = true;\n\t            if (enabledStateEvents[\"$stateNotFound\"])\n\t                $stateProvider.onInvalid(stateNotFoundHandler);\n\t            if (enabledStateEvents.$stateChangeStart)\n\t                $transitions.onBefore({}, stateChangeStartHandler, { priority: 1000 });\n\t            return {\n\t                provider: $StateEventsProvider.prototype.instance\n\t            };\n\t        }\n\t    }\n\t    angular.module('ui.router.state.events', ['ui.router.state'])\n\t        .provider(\"$stateEvents\", $StateEventsProvider)\n\t        .run(['$stateEvents', function ($stateEvents) {\n\t        }]);\n\t})();\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** stateEvents.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a4ffa6d2207b695a9deb\n **/","/**\n * Provides implementation of the UI-Router 0.2.x state events.\n *\n * The 0.2.x state events are deprecated.  We recommend moving to Transition Hooks instead, as they\n * provide much more flexibility, support async, and provide the context (the Transition, etc) necessary\n * to implement meaningful application behaviors.\n *\n * To enable these state events, include the `stateEvents.js` file in your project, e.g.,\n * ```\n * <script src=\"stateEvents.js\"></script>\n * ```\n * and also make sure you depend on the `ui.router.state.events` angular module, e.g.,\n * ```\n * angular.module(\"myApplication\", ['ui.router', 'ui.router.state.events']\n * ```\n *\n * @module ng1_state_events\n */ /** */\nimport {IServiceProviderFactory} from \"angular\";\nimport {TargetState, StateService, StateProvider} from \"../state/module\";\nimport {Transition} from \"../transition/transition\";\n\n/**\n * An event broadcast on `$rootScope` when the state transition **begins**.\n *\n * You can use `event.preventDefault()`\n * to prevent the transition from happening and then the transition promise will be\n * rejected with a `'transition prevented'` value.\n *\n * Additional arguments to the event handler are provided:\n * - `toState`: the Transition Target state\n * - `toParams`: the Transition Target Params\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `options`: any Transition Options\n * - `$transition$`: the [[Transition]]\n *\n * @example\n * ```\n *\n * $rootScope.$on('$stateChangeStart', function(event, transition) {\n *   event.preventDefault();\n *   // transitionTo() promise will be rejected with\n *   // a 'transition prevented' error\n * })\n * ```\n *\n * @deprecated use [[TransitionService.onStart]]\n * @event $stateChangeStart\n */\nvar $stateChangeStart;\n\n/**\n * An event broadcast on `$rootScope` if a transition is **cancelled**.\n *\n * Additional arguments to the event handler are provided:\n * - `toState`: the Transition Target state\n * - `toParams`: the Transition Target Params\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `options`: any Transition Options\n * - `$transition$`: the [[Transition]] that was cancelled\n *\n * @deprecated\n * @event $stateChangeCancel\n */\nvar $stateChangeCancel;\n\n/**\n *\n * An event broadcast on `$rootScope` once the state transition is **complete**.\n *\n * Additional arguments to the event handler are provided:\n * - `toState`: the Transition Target state\n * - `toParams`: the Transition Target Params\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `options`: any Transition Options\n * - `$transition$`: the [[Transition]] that just succeeded\n *\n * @deprecated use [[TransitionService.onStart]] and [[Transition.promise]], or [[Transition.onSuccess]]\n * @event $stateChangeSuccess\n */\nvar $stateChangeSuccess;\n\n/**\n * An event broadcast on `$rootScope` when an **error occurs** during transition.\n *\n * It's important to note that if you\n * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n * they will not throw traditionally. You must listen for this $stateChangeError event to\n * catch **ALL** errors.\n *\n * Additional arguments to the event handler are provided:\n * - `toState`: the Transition Target state\n * - `toParams`: the Transition Target Params\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `error`: The reason the transition errored.\n * - `options`: any Transition Options\n * - `$transition$`: the [[Transition]] that errored\n *\n * @deprecated use [[TransitionService.onStart]] and [[Transition.promise]], or [[Transition.onError]]\n * @event $stateChangeError\n */\nvar $stateChangeError;\n\n/**\n * An event broadcast on `$rootScope` when a requested state **cannot be found** using the provided state name.\n *\n * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n * lazy-loading the unfound state). A `TargetState` object is passed to the listener handler,\n * you can see its properties in the example. You can use `event.preventDefault()` to abort the\n * transition and the promise returned from `transitionTo()` will be rejected with a\n * `'transition aborted'` error.\n *\n * Additional arguments to the event handler are provided:\n * - `unfoundState` Unfound State information. Contains: `to, toParams, options` properties.\n * - `fromState`: the state the transition is coming from\n * - `fromParams`: the parameters from the state the transition is coming from\n * - `options`: any Transition Options\n * @example\n *\n * <pre>\n * // somewhere, assume lazy.state has not been defined\n * $state.go(\"lazy.state\", { a: 1, b: 2 }, { inherit: false });\n *\n * // somewhere else\n * $scope.$on('$stateNotFound', function(event, transition) {\n * function(event, unfoundState, fromState, fromParams){\n *     console.log(unfoundState.to); // \"lazy.state\"\n *     console.log(unfoundState.toParams); // {a:1, b:2}\n *     console.log(unfoundState.options); // {inherit:false} + default options\n * });\n * </pre>\n *\n * @deprecated use [[StateProvider.onInvalid]] // TODO: Move to [[StateService.onInvalid]]\n * @event $stateNotFound\n */\nvar $stateNotFound;\n\n\n(function() {\n  let {isFunction, isString} = angular;\n\n  function applyPairs(memo, keyValTuple: any[]) {\n    let key, value;\n    if (Array.isArray(keyValTuple)) [key, value] = keyValTuple;\n    if (!isString(key)) throw new Error(\"invalid parameters to applyPairs\");\n    memo[key] = value;\n    return memo;\n  }\n\n  stateChangeStartHandler.$inject = ['$transition$', '$stateEvents', '$rootScope', '$state', '$urlRouter'];\n  function stateChangeStartHandler($transition$: Transition, $stateEvents, $rootScope, $state, $urlRouter) {\n    if (!$transition$.options().notify || !$transition$.valid() || $transition$.ignored())\n      return;\n\n    let enabledEvents = $stateEvents.provider.enabled();\n\n\n    let toParams = $transition$.params(\"to\");\n    let fromParams = $transition$.params(\"from\");\n\n    if (enabledEvents.$stateChangeSuccess) {\n      let startEvent = $rootScope.$broadcast('$stateChangeStart', $transition$.to(), toParams, $transition$.from(), fromParams, $transition$.options(), $transition$);\n\n      if (startEvent.defaultPrevented) {\n        if (enabledEvents.$stateChangeCancel) {\n          $rootScope.$broadcast('$stateChangeCancel', $transition$.to(), toParams, $transition$.from(), fromParams, $transition$.options(), $transition$);\n        }\n        //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n        if ($state.transition == null) $urlRouter.update();\n        return false;\n      }\n\n      $transition$.promise.then(function () {\n        $rootScope.$broadcast('$stateChangeSuccess', $transition$.to(), toParams, $transition$.from(), fromParams, $transition$.options(), $transition$);\n      });\n    }\n\n    if (enabledEvents.$stateChangeError) {\n      $transition$.promise[\"catch\"](function (error) {\n        if (error && (error.type === 2 /* RejectType.SUPERSEDED */ || error.type === 3 /* RejectType.ABORTED */))\n          return;\n\n\n        let evt = $rootScope.$broadcast('$stateChangeError', $transition$.to(), toParams, $transition$.from(), fromParams, error, $transition$.options(), $transition$);\n\n        if (!evt.defaultPrevented) {\n          $urlRouter.update();\n        }\n      });\n    }\n  }\n\n  stateNotFoundHandler.$inject = ['$to$', '$from$', '$state', '$rootScope', '$urlRouter'];\n  function stateNotFoundHandler($to$: TargetState, $from$: TargetState, $state: StateService, $rootScope, $urlRouter) {\n    let redirect = {to: $to$.identifier(), toParams: $to$.params(), options: $to$.options()};\n    let e = $rootScope.$broadcast('$stateNotFound', redirect, $from$.state(), $from$.params());\n\n    if (e.defaultPrevented || e.retry)\n      $urlRouter.update();\n\n    function redirectFn(): TargetState {\n      return $state.target(redirect.to, redirect.toParams, redirect.options);\n    }\n\n    if (e.defaultPrevented) {\n      return false;\n    } else if (e.retry || !!$state.get(redirect.to)) {\n      return e.retry && isFunction(e.retry.then) ? e.retry.then(redirectFn) : redirectFn();\n    }\n  }\n\n  $StateEventsProvider.$inject = ['$stateProvider'];\n  function $StateEventsProvider($stateProvider: StateProvider) {\n    $StateEventsProvider.prototype.instance = this;\n\n    interface IEventsToggle {\n      $stateChangeStart: boolean;\n      $stateNotFound: boolean;\n      $stateChangeSuccess: boolean;\n      $stateChangeError: boolean;\n    }\n\n    let runtime = false;\n    let allEvents = ['$stateChangeStart', '$stateNotFound', '$stateChangeSuccess', '$stateChangeError'];\n    let enabledStateEvents = <IEventsToggle> allEvents.map(e => [e, true]).reduce(applyPairs, {});\n\n    function assertNotRuntime() {\n      if (runtime) throw new Error(\"Cannot enable events at runtime (use $stateEventsProvider\");\n    }\n\n    /**\n     * Enables the deprecated UI-Router 0.2.x State Events\n     * [ '$stateChangeStart', '$stateNotFound', '$stateChangeSuccess', '$stateChangeError' ]\n     */\n    this.enable = function (...events: string[]) {\n      assertNotRuntime();\n      if (!events || !events.length) events = allEvents;\n      events.forEach(event => enabledStateEvents[event] = true);\n    };\n\n    /**\n     * Disables the deprecated UI-Router 0.2.x State Events\n     * [ '$stateChangeStart', '$stateNotFound', '$stateChangeSuccess', '$stateChangeError' ]\n     */\n    this.disable = function (...events: string[]) {\n      assertNotRuntime();\n      if (!events || !events.length) events = allEvents;\n      events.forEach(event => delete enabledStateEvents[event]);\n    };\n\n    this.enabled = () => enabledStateEvents;\n\n    this.$get = $get;\n    $get.$inject = ['$transitions'];\n    function $get($transitions) {\n      runtime = true;\n\n      if (enabledStateEvents[\"$stateNotFound\"])\n        $stateProvider.onInvalid(stateNotFoundHandler);\n      if (enabledStateEvents.$stateChangeStart)\n        $transitions.onBefore({}, stateChangeStartHandler, {priority: 1000});\n\n      return {\n        provider: $StateEventsProvider.prototype.instance\n      };\n    }\n  }\n\n\n  angular.module('ui.router.state.events', ['ui.router.state'])\n      .provider(\"$stateEvents\", <IServiceProviderFactory> $StateEventsProvider)\n      .run(['$stateEvents', function ($stateEvents) { /* Invokes $get() */\n      }]);\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./ng1/stateEvents.ts\n **/"],"sourceRoot":""}